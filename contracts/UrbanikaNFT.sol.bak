// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// Chainlink Price Feed interface
interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 price,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function decimals() external view returns (uint8);
}

// ============ Custom Errors ============
error InvalidAddress();
error MaxSupplyReached();
error AmountBelowMinimum();
error InvalidTokenURI();
error URIAlreadyUsed();
error MintingPaused();
error FailedToSendETH();
error TokenNotAccepted();
error TokenDoesNotExist();
error InvestmentNotActive();
error AmountMustBeGreaterThanZero();
error InvalidTreasuryAddress();
error MinimumMustBeGreaterThanZero();
error PriceMustBeGreaterThanZero();
error PriceIncorrect();
error TimelockNotExpired();
error InvalidTokenAddress();
error InvestmentAlreadyCompleted();
error ExceedsExpectedReturn();
error InsufficientETHBalance();
error InsufficientUSDCBalance();
error InsufficientUSDTBalance();
error EmptyTokenArray();
error NoPendingReturns();
error SameAsCurrentTreasury();
error NoPendingTreasuryChange();
error NoETHBalance();
error NoTokenBalance();

/**
 * @title UrbanikaNFT - Production Ready Version 2
 * @dev NFT de inversión para Urbanika - Red Scroll
 * @notice Cada NFT representa una inversión en el ecosistema de casas regenerativas
 *
 * Características v2.0 (Sin conversión a MXN):
 * - Inversiones directas en ETH, USDC o USDT
 * - Sistema de retorno 1.5x basado en ventas de casas
 * - Tiers de inversión (Bronze, Silver, Gold, Platinum)
 * - Distribución de ganancias proporcional
 * - MAX_SUPPLY para evitar dilución
 * - Treasury con timelock para cambios
 * - Email hasheado para privacidad
 * - Metadata almacenado en IPFS
 */
contract UrbanikaNFT is
    ERC721,
    ERC721URIStorage,
    ERC721Enumerable,
    Ownable,
    Pausable,
    ReentrancyGuard
{
    using SafeERC20 for IERC20;

    // ============ Enums ============

    enum PaymentToken {
        ETH,
        USDC,
        USDT
    }

    enum InvestmentTier {
        Bronze,    // < $25 USD
        Silver,    // $25 - $250 USD
        Gold,      // $250 - $500 USD
        Platinum   // >= $500 USD
    }

    // ============ Structs ============

    struct Investment {
        uint256 investmentAmount;      // Monto invertido (en wei de la moneda original)
        uint256 expectedReturn;        // Retorno esperado (1.5x)
        uint256 currentReturn;         // Retorno acumulado recibido
        uint256 mintDate;              // Timestamp de creación
        InvestmentTier tier;           // Nivel de inversión
        PaymentToken paymentToken;     // Token usado para el pago
        bool isActive;                 // Estado del NFT
        address investor;              // Wallet del inversor
        bytes32 emailHash;             // Hash del email (para privacidad)
    }

    // ============ State Variables ============

    uint256 private _tokenIdCounter;

    // Mappings
    mapping(uint256 => Investment) public investments;
    mapping(address => uint256[]) private _investorTokens;
    mapping(bytes32 => bool) private _usedURIs; // Prevenir URIs duplicados

    // Constants
    uint256 public constant RETURN_MULTIPLIER = 150; // 1.5x = 150%
    uint256 public constant MULTIPLIER_BASE = 100;
    uint256 public constant MAX_SUPPLY = 10000; // Límite máximo de NFTs

    // Minimums por tier en USD (usando 18 decimales para consistencia)
    // 1 USD = 1e18 wei en nuestra representación interna
    uint256 public constant MIN_BRONZE = 0;               // Bronze es < $25 USD
    uint256 public constant MIN_SILVER = 25 * 1e18;       // $25 USD
    uint256 public constant MIN_GOLD = 250 * 1e18;       // $250 USD
    uint256 public constant MIN_PLATINUM = 500 * 1e18;    // $500 USD

    // Total stats por tipo de token
    mapping(PaymentToken => uint256) public totalInvestmentByToken;
    mapping(PaymentToken => uint256) public totalDistributedByToken;
    uint256 public activeNFTCount;

    // Precios mínimos de inversión por token
    // ETH: 18 decimales
    // USDC: 6 decimales en Scroll
    // USDT: 6 decimales en Scroll
    uint256 public minInvestmentETH = 0.004 ether;    // Mínimo 0.004 ETH (~$10 USD a $2500/ETH)
    uint256 public minInvestmentUSDC = 10 * 1e6;      // Mínimo 10 USDC
    uint256 public minInvestmentUSDT = 10 * 1e6;      // Mínimo 10 USDT

    // Direcciones de tokens ERC20 (Scroll Mainnet)
    address public constant USDC = 0x06eFdBFf2a14a7c8E15944D1F4A48F9F95F663A4;
    address public constant USDT = 0xf55BEC9cafDbE8730f096Aa55dad6D22d44099Df;

    mapping(address => bool) public acceptedTokens;

    // Treasury con timelock
    address payable public treasury;
    address payable public pendingTreasury;
    uint256 public treasuryChangeTimestamp;
    uint256 public constant TREASURY_TIMELOCK = 7 days;

    // Pausa independiente de minting
    bool public mintPaused = false;

    // Oracle de precios Chainlink
    AggregatorV3Interface public ethPriceFeed;
    uint256 public constant PRICE_STALENESS_THRESHOLD = 3600; // 1 hora
    uint256 public manualETHPrice = 2500 * 1e8; // Precio manual de respaldo ($2500 con 8 decimales)

    // ============ Events ============

    event NFTMinted(
        uint256 indexed tokenId,
        address indexed investor,
        uint256 investmentAmount,
        PaymentToken paymentToken,
        InvestmentTier tier,
        uint256 expectedReturn
    );

    event ReturnDistributed(
        uint256 indexed tokenId,
        uint256 amount,
        PaymentToken paymentToken,
        uint256 totalReceived
    );

    event InvestmentCompleted(
        uint256 indexed tokenId,
        address indexed investor,
        uint256 totalReturn,
        PaymentToken paymentToken
    );

    event MetadataUpdated(
        uint256 indexed tokenId,
        string newTokenURI
    );

    event TreasuryChangeProposed(
        address indexed oldTreasury,
        address indexed newTreasury,
        uint256 unlockTime
    );

    event TreasuryUpdated(
        address indexed oldTreasury,
        address indexed newTreasury
    );

    event MinInvestmentUpdated(
        PaymentToken indexed token,
        uint256 oldMin,
        uint256 newMin
    );

    event MintPauseToggled(bool isPaused);

    event TokenAcceptanceToggled(
        address indexed token,
        bool isAccepted
    );

    event PriceFeedUpdated(
        address indexed oldFeed,
        address indexed newFeed
    );

    event ManualPriceUpdated(
        uint256 oldPrice,
        uint256 newPrice
    );

    // ============ Modifiers ============

    modifier whenMintNotPaused() {
        if (mintPaused) revert MintingPaused();
        _;
    }

    // ============ Constructor ============

    constructor(address payable _treasury)
        ERC721("Urbanika Investment NFT", "URBINV")
        Ownable(msg.sender)
    {
        if (_treasury == address(0)) revert InvalidTreasuryAddress();
        treasury = _treasury;
        _tokenIdCounter = 0;
        activeNFTCount = 0;

        // Configurar tokens aceptados
        acceptedTokens[USDC] = true;
        acceptedTokens[USDT] = true;
    }

    // ============ Minting Functions ============

    /**
     * @dev Acuña un nuevo NFT de inversión (solo owner - para pagos off-chain)
     * @param to Dirección del inversor
     * @param investmentAmount Monto invertido (en wei del token correspondiente)
     * @param paymentToken Token usado para el pago (ETH, USDC, USDT)
     * @param _tokenURI URI del metadata en IPFS
     * @param investorEmail Email del inversor (se hasheará)
     * @return tokenId ID del NFT creado
     */
    function mint(
        address to,
        uint256 investmentAmount,
        PaymentToken paymentToken,
        string memory _tokenURI,
        string memory investorEmail
    ) public onlyOwner whenNotPaused whenMintNotPaused returns (uint256) {
        if (to == address(0)) revert InvalidAddress();
        if (_tokenIdCounter >= MAX_SUPPLY) revert MaxSupplyReached();
        if (!_validateMinInvestment(investmentAmount, paymentToken)) revert AmountBelowMinimum();
        if (bytes(_tokenURI).length == 0) revert InvalidTokenURI();

        // Verificar URI único
        bytes32 uriHash = keccak256(bytes(_tokenURI));
        if (_usedURIs[uriHash]) revert URIAlreadyUsed();
        _usedURIs[uriHash] = true;

        _tokenIdCounter++;
        uint256 tokenId = _tokenIdCounter;

        // Calcular tier basado en valor en USD (normalizado a 18 decimales)
        uint256 normalizedAmount = _normalizeToUSD(investmentAmount, paymentToken);
        InvestmentTier tier = _calculateTier(normalizedAmount);

        // Calcular retorno esperado (1.5x en el token original)
        uint256 expectedReturn = (investmentAmount * RETURN_MULTIPLIER) / MULTIPLIER_BASE;

        // Hash del email para privacidad
        bytes32 emailHash = keccak256(bytes(investorEmail));

        // Crear investment
        investments[tokenId] = Investment({
            investmentAmount: investmentAmount,
            expectedReturn: expectedReturn,
            currentReturn: 0,
            mintDate: block.timestamp,
            tier: tier,
            paymentToken: paymentToken,
            isActive: true,
            investor: to,
            emailHash: emailHash
        });

        // Actualizar stats
        totalInvestmentByToken[paymentToken] += investmentAmount;
        activeNFTCount++;

        // Guardar relación inversor-token
        _investorTokens[to].push(tokenId);

        // Mint NFT
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, _tokenURI);

        emit NFTMinted(tokenId, to, investmentAmount, paymentToken, tier, expectedReturn);

        return tokenId;
    }

    /**
     * @dev Mintea NFT con pago en ETH (público)
     * @param _tokenURI URI del metadata en IPFS
     * @return tokenId ID del NFT creado
     */
    function publicMintWithETH(
        string memory _tokenURI
    ) public payable whenNotPaused whenMintNotPaused nonReentrant returns (uint256) {
        if (_tokenIdCounter >= MAX_SUPPLY) revert MaxSupplyReached();
        if (msg.value < minInvestmentETH) revert AmountBelowMinimum();
        if (bytes(_tokenURI).length == 0) revert InvalidTokenURI();

        // Verificar URI único
        bytes32 uriHash = keccak256(bytes(_tokenURI));
        if (_usedURIs[uriHash]) revert URIAlreadyUsed();
        _usedURIs[uriHash] = true;

        _tokenIdCounter++;
        uint256 tokenId = _tokenIdCounter;

        uint256 investmentAmount = msg.value;

        // Calcular tier
        uint256 normalizedAmount = _normalizeToUSD(investmentAmount, PaymentToken.ETH);
        InvestmentTier tier = _calculateTier(normalizedAmount);

        // Calcular retorno esperado (1.5x)
        uint256 expectedReturn = (investmentAmount * RETURN_MULTIPLIER) / MULTIPLIER_BASE;

        // Crear investment (sin email en public mint)
        investments[tokenId] = Investment({
            investmentAmount: investmentAmount,
            expectedReturn: expectedReturn,
            currentReturn: 0,
            mintDate: block.timestamp,
            tier: tier,
            paymentToken: PaymentToken.ETH,
            isActive: true,
            investor: msg.sender,
            emailHash: bytes32(0)
        });

        // Actualizar stats
        totalInvestmentByToken[PaymentToken.ETH] += investmentAmount;
        activeNFTCount++;

        // Guardar relación inversor-token
        _investorTokens[msg.sender].push(tokenId);

        // Mint NFT
        _safeMint(msg.sender, tokenId);
        _setTokenURI(tokenId, _tokenURI);

        emit NFTMinted(tokenId, msg.sender, investmentAmount, PaymentToken.ETH, tier, expectedReturn);

        // Enviar fondos a treasury
        (bool sent, ) = treasury.call{value: investmentAmount}("");
        if (!sent) revert FailedToSendETH();

        return tokenId;
    }

    /**
     * @dev Mintea NFT con pago en USDC o USDT (público)
     * @param amount Cantidad de tokens a pagar
     * @param _tokenURI URI del metadata en IPFS
     * @param paymentTokenAddress Dirección del token ERC20 (USDC o USDT)
     * @return tokenId ID del NFT creado
     */
    function publicMintWithToken(
        uint256 amount,
        string memory _tokenURI,
        address paymentTokenAddress
    ) public whenNotPaused whenMintNotPaused nonReentrant returns (uint256) {
        if (!acceptedTokens[paymentTokenAddress]) revert TokenNotAccepted();
        if (_tokenIdCounter >= MAX_SUPPLY) revert MaxSupplyReached();
        if (bytes(_tokenURI).length == 0) revert InvalidTokenURI();

        // Determinar tipo de token y validar monto mínimo
        PaymentToken paymentToken = _getPaymentTokenType(paymentTokenAddress);
        if (!_validateMinInvestment(amount, paymentToken)) revert AmountBelowMinimum();

        // Verificar URI único
        bytes32 uriHash = keccak256(bytes(_tokenURI));
        if (_usedURIs[uriHash]) revert URIAlreadyUsed();
        _usedURIs[uriHash] = true;

        // Transferir tokens del comprador al treasury
        IERC20(paymentTokenAddress).safeTransferFrom(msg.sender, treasury, amount);

        _tokenIdCounter++;
        uint256 tokenId = _tokenIdCounter;

        // Calcular tier
        uint256 normalizedAmount = _normalizeToUSD(amount, paymentToken);
        InvestmentTier tier = _calculateTier(normalizedAmount);

        // Calcular retorno esperado (1.5x)
        uint256 expectedReturn = (amount * RETURN_MULTIPLIER) / MULTIPLIER_BASE;

        // Crear investment
        investments[tokenId] = Investment({
            investmentAmount: amount,
            expectedReturn: expectedReturn,
            currentReturn: 0,
            mintDate: block.timestamp,
            tier: tier,
            paymentToken: paymentToken,
            isActive: true,
            investor: msg.sender,
            emailHash: bytes32(0)
        });

        // Actualizar stats
        totalInvestmentByToken[paymentToken] += amount;
        activeNFTCount++;

        // Guardar relación inversor-token
        _investorTokens[msg.sender].push(tokenId);

        // Mint NFT
        _safeMint(msg.sender, tokenId);
        _setTokenURI(tokenId, _tokenURI);

        emit NFTMinted(tokenId, msg.sender, amount, paymentToken, tier, expectedReturn);

        return tokenId;
    }

    // ============ Distribution Functions ============

    /**
     * @dev Distribuye retornos a un NFT específico
     * @param tokenId ID del NFT
     * @param amount Cantidad a distribuir (en el token original de inversión)
     */
    function distributeReturn(uint256 tokenId, uint256 amount)
        public
        onlyOwner
        nonReentrant
    {
        if (_ownerOf(tokenId) == address(0)) revert TokenDoesNotExist();
        Investment storage investment = investments[tokenId];
        if (!investment.isActive) revert InvestmentNotActive();
        if (amount == 0) revert AmountMustBeGreaterThanZero();

        uint256 remainingReturn = investment.expectedReturn - investment.currentReturn;
        if (remainingReturn == 0) revert InvestmentAlreadyCompleted();

        uint256 amountToDistribute = amount > remainingReturn ? remainingReturn : amount;

        // Validar que el contrato tenga fondos suficientes
        if (investment.paymentToken == PaymentToken.ETH) {
            if (address(this).balance < amountToDistribute) revert InsufficientETHBalance();
        } else if (investment.paymentToken == PaymentToken.USDC) {
            if (IERC20(USDC).balanceOf(address(this)) < amountToDistribute) revert InsufficientUSDCBalance();
        } else if (investment.paymentToken == PaymentToken.USDT) {
            if (IERC20(USDT).balanceOf(address(this)) < amountToDistribute) revert InsufficientUSDTBalance();
        }

        // Actualizar retorno actual
        investment.currentReturn += amountToDistribute;
        totalDistributedByToken[investment.paymentToken] += amountToDistribute;

        // Transferir fondos según el tipo de token
        address investor = investment.investor;

        if (investment.paymentToken == PaymentToken.ETH) {
            (bool sent, ) = payable(investor).call{value: amountToDistribute}("");
            if (!sent) revert FailedToSendETH();
        } else if (investment.paymentToken == PaymentToken.USDC) {
            IERC20(USDC).safeTransfer(investor, amountToDistribute);
        } else if (investment.paymentToken == PaymentToken.USDT) {
            IERC20(USDT).safeTransfer(investor, amountToDistribute);
        }

        emit ReturnDistributed(
            tokenId, 
            amountToDistribute, 
            investment.paymentToken,
            investment.currentReturn
        );

        // Si completó el retorno esperado, marcar como completado
        if (investment.currentReturn >= investment.expectedReturn) {
            investment.isActive = false;
            activeNFTCount--;
            emit InvestmentCompleted(
                tokenId, 
                investor, 
                investment.currentReturn,
                investment.paymentToken
            );
        }
    }

    /**
     * @dev Distribuye retornos a múltiples NFTs de forma proporcional
     * @param tokenIds Array de IDs de NFTs
     * @param totalAmount Cantidad total a distribuir
     * @param paymentToken Token en el que se distribuirá
     */
    function batchDistributeReturns(
        uint256[] memory tokenIds,
        uint256 totalAmount,
        PaymentToken paymentToken
    ) public onlyOwner nonReentrant {
        if (tokenIds.length == 0) revert EmptyTokenArray();
        if (totalAmount == 0) revert AmountMustBeGreaterThanZero();

        // Calcular total de retornos pendientes para estos NFTs (solo del mismo token)
        uint256 totalPendingReturns = 0;
        for (uint256 i = 0; i < tokenIds.length; i++) {
            Investment storage inv = investments[tokenIds[i]];
            if (inv.isActive && inv.paymentToken == paymentToken) {
                totalPendingReturns += (inv.expectedReturn - inv.currentReturn);
            }
        }

        if (totalPendingReturns == 0) revert NoPendingReturns();

        // Distribuir proporcionalmente
        for (uint256 i = 0; i < tokenIds.length; i++) {
            Investment storage inv = investments[tokenIds[i]];
            
            if (!inv.isActive || inv.paymentToken != paymentToken) continue;

            uint256 pendingReturn = inv.expectedReturn - inv.currentReturn;
            if (pendingReturn == 0) continue;

            // Calcular proporción
            uint256 distributionAmount = (totalAmount * pendingReturn) / totalPendingReturns;
            
            if (distributionAmount > 0) {
                distributeReturn(tokenIds[i], distributionAmount);
            }
        }
    }

    // ============ View Functions ============

    /**
     * @dev Obtiene información de una inversión
     */
    function getInvestment(uint256 tokenId) 
        public 
        view 
        returns (Investment memory) 
    {
        require(_ownerOf(tokenId) != address(0), "Token does not exist");
        return investments[tokenId];
    }

    /**
     * @dev Obtiene todos los NFTs de un inversor
     */
    function getInvestorTokens(address investor) 
        public 
        view 
        returns (uint256[] memory) 
    {
        return _investorTokens[investor];
    }

    /**
     * @dev Obtiene el retorno pendiente de un NFT
     */
    function getPendingReturn(uint256 tokenId) 
        public 
        view 
        returns (uint256) 
    {
        require(_ownerOf(tokenId) != address(0), "Token does not exist");
        Investment memory investment = investments[tokenId];
        return investment.expectedReturn - investment.currentReturn;
    }

    /**
     * @dev Obtiene estadísticas de un tipo de token
     */
    function getTokenStats(PaymentToken token)
        public
        view
        returns (uint256 totalInvested, uint256 totalDistributed)
    {
        return (
            totalInvestmentByToken[token],
            totalDistributedByToken[token]
        );
    }

    /**
     * @dev Obtiene el balance del contrato para un tipo de token
     */
    function getContractBalance(PaymentToken token)
        public
        view
        returns (uint256)
    {
        if (token == PaymentToken.ETH) {
            return address(this).balance;
        } else if (token == PaymentToken.USDC) {
            return IERC20(USDC).balanceOf(address(this));
        } else if (token == PaymentToken.USDT) {
            return IERC20(USDT).balanceOf(address(this));
        }
        return 0;
    }

    /**
     * @dev Obtiene todos los NFTs activos
     */
    function getActiveNFTs() 
        public 
        view 
        returns (uint256[] memory) 
    {
        uint256[] memory activeTokens = new uint256[](activeNFTCount);
        uint256 currentIndex = 0;

        for (uint256 i = 1; i <= _tokenIdCounter; i++) {
            if (investments[i].isActive) {
                activeTokens[currentIndex] = i;
                currentIndex++;
            }
        }

        return activeTokens;
    }

    // ============ Admin Functions ============

    /**
     * @dev Actualiza el monto mínimo de inversión para un token
     */
    function setMinInvestment(PaymentToken token, uint256 newMin) 
        public 
        onlyOwner 
    {
        require(newMin > 0, "Minimum must be greater than 0");
        
        uint256 oldMin;
        
        if (token == PaymentToken.ETH) {
            oldMin = minInvestmentETH;
            minInvestmentETH = newMin;
        } else if (token == PaymentToken.USDC) {
            oldMin = minInvestmentUSDC;
            minInvestmentUSDC = newMin;
        } else if (token == PaymentToken.USDT) {
            oldMin = minInvestmentUSDT;
            minInvestmentUSDT = newMin;
        }

        emit MinInvestmentUpdated(token, oldMin, newMin);
    }

    /**
     * @dev Actualiza el metadata de un NFT
     */
    function updateTokenURI(uint256 tokenId, string memory newTokenURI) 
        public 
        onlyOwner 
    {
        require(_ownerOf(tokenId) != address(0), "Token does not exist");
        require(bytes(newTokenURI).length > 0, "Invalid token URI");
        
        _setTokenURI(tokenId, newTokenURI);
        emit MetadataUpdated(tokenId, newTokenURI);
    }

    /**
     * @dev Activa/desactiva un token como método de pago
     */
    function setTokenAcceptance(address tokenAddress, bool isAccepted) 
        public 
        onlyOwner 
    {
        require(tokenAddress != address(0), "Invalid token address");
        acceptedTokens[tokenAddress] = isAccepted;
        emit TokenAcceptanceToggled(tokenAddress, isAccepted);
    }

    /**
     * @dev Pausa/despausa el minting
     */
    function toggleMintPause() public onlyOwner {
        mintPaused = !mintPaused;
        emit MintPauseToggled(mintPaused);
    }

    /**
     * @dev Pausa el contrato completo (emergencia)
     */
    function pause() public onlyOwner {
        _pause();
    }

    /**
     * @dev Despausa el contrato
     */
    function unpause() public onlyOwner {
        _unpause();
    }

    /**
     * @dev Propone cambio de treasury (paso 1 - con timelock)
     */
    function proposeTreasuryChange(address payable newTreasury) 
        public 
        onlyOwner 
    {
        require(newTreasury != address(0), "Invalid treasury address");
        require(newTreasury != treasury, "Same as current treasury");

        pendingTreasury = newTreasury;
        treasuryChangeTimestamp = block.timestamp + TREASURY_TIMELOCK;

        emit TreasuryChangeProposed(treasury, newTreasury, treasuryChangeTimestamp);
    }

    /**
     * @dev Ejecuta cambio de treasury (paso 2 - después del timelock)
     */
    function executeTreasuryChange() public onlyOwner {
        require(pendingTreasury != address(0), "No pending treasury change");
        require(block.timestamp >= treasuryChangeTimestamp, "Timelock not expired");

        address payable oldTreasury = treasury;
        treasury = pendingTreasury;
        pendingTreasury = payable(address(0));
        treasuryChangeTimestamp = 0;

        emit TreasuryUpdated(oldTreasury, treasury);
    }

    /**
     * @dev Cancela cambio de treasury pendiente
     */
    function cancelTreasuryChange() public onlyOwner {
        require(pendingTreasury != address(0), "No pending treasury change");
        pendingTreasury = payable(address(0));
        treasuryChangeTimestamp = 0;
    }

    /**
     * @dev Configura el Price Feed de Chainlink para ETH/USD
     */
    function setPriceFeed(address _priceFeed) public onlyOwner {
        address oldFeed = address(ethPriceFeed);
        ethPriceFeed = AggregatorV3Interface(_priceFeed);
        emit PriceFeedUpdated(oldFeed, _priceFeed);
    }

    /**
     * @dev Actualiza el precio manual de ETH (respaldo si falla oracle)
     * @param newPrice Precio en USD con 8 decimales (ej: 2500_00000000 = $2500)
     */
    function setManualETHPrice(uint256 newPrice) public onlyOwner {
        require(newPrice > 0, "Price must be greater than 0");
        require(newPrice < 1000000 * 1e8, "Price seems incorrect"); // Max $1M por ETH
        uint256 oldPrice = manualETHPrice;
        manualETHPrice = newPrice;
        emit ManualPriceUpdated(oldPrice, newPrice);
    }

    /**
     * @dev Retira ETH del contrato (solo owner)
     */
    function withdrawETH() public onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No ETH balance");
        (bool sent, ) = treasury.call{value: balance}("");
        require(sent, "Failed to send ETH");
    }

    /**
     * @dev Retira tokens ERC20 del contrato (solo owner)
     */
    function withdrawTokens(address tokenAddress) public onlyOwner {
        require(tokenAddress != address(0), "Invalid token address");
        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
        require(balance > 0, "No token balance");
        IERC20(tokenAddress).safeTransfer(treasury, balance);
    }

    /**
     * @dev Permite recibir ETH en el contrato
     */
    receive() external payable {}

    // ============ Internal Functions ============

    /**
     * @dev Calcula el tier basado en el monto normalizado a USD
     */
    function _calculateTier(uint256 normalizedAmount) 
        internal 
        pure 
        returns (InvestmentTier) 
    {
        if (normalizedAmount >= MIN_PLATINUM) return InvestmentTier.Platinum;
        if (normalizedAmount >= MIN_GOLD) return InvestmentTier.Gold;
        if (normalizedAmount >= MIN_SILVER) return InvestmentTier.Silver;
        return InvestmentTier.Bronze;
    }

    /**
     * @dev Obtiene el precio de ETH en USD de forma segura
     * @return price Precio de ETH en USD con 18 decimales
     */
    function getETHPriceUSD() public view returns (uint256 price) {
        if (address(ethPriceFeed) != address(0)) {
            try ethPriceFeed.latestRoundData() returns (
                uint80,
                int256 priceInt,
                uint256,
                uint256 updatedAt,
                uint80
            ) {
                // Verificar que el precio es válido y no está obsoleto
                if (priceInt > 0 && block.timestamp - updatedAt <= PRICE_STALENESS_THRESHOLD) {
                    // Chainlink devuelve precio con 8 decimales, convertir a 18
                    return uint256(priceInt) * 1e10;
                }
            } catch {
                // Si falla el oracle, usar precio manual
            }
        }
        // Usar precio manual de respaldo (convertir de 8 a 18 decimales)
        return manualETHPrice * 1e10;
    }

    /**
     * @dev Normaliza el monto a USD con 18 decimales para comparación
     * Usa Oracle de Chainlink para ETH, asume $1 para stablecoins
     */
    function _normalizeToUSD(uint256 amount, PaymentToken token)
        internal
        view
        returns (uint256)
    {
        if (token == PaymentToken.ETH) {
            // amount está en wei (18 decimales)
            // ethPrice está en 18 decimales
            // Resultado debe estar en 18 decimales
            uint256 ethPrice = getETHPriceUSD();
            return (amount * ethPrice) / 1e18;
        } else if (token == PaymentToken.USDC || token == PaymentToken.USDT) {
            // USDC/USDT tienen 6 decimales, convertir a 18 decimales
            return amount * 1e12;
        }
        return 0;
    }

    /**
     * @dev Valida el monto mínimo de inversión según el token
     */
    function _validateMinInvestment(uint256 amount, PaymentToken token) 
        internal 
        view 
        returns (bool) 
    {
        if (token == PaymentToken.ETH) {
            return amount >= minInvestmentETH;
        } else if (token == PaymentToken.USDC) {
            return amount >= minInvestmentUSDC;
        } else if (token == PaymentToken.USDT) {
            return amount >= minInvestmentUSDT;
        }
        return false;
    }

    /**
     * @dev Obtiene el tipo de PaymentToken desde una dirección
     */
    function _getPaymentTokenType(address tokenAddress) 
        internal 
        pure 
        returns (PaymentToken) 
    {
        if (tokenAddress == USDC) {
            return PaymentToken.USDC;
        } else if (tokenAddress == USDT) {
            return PaymentToken.USDT;
        }
        revert("Invalid token address");
    }

    // ============ Required Overrides ============

    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721, ERC721Enumerable)
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(address account, uint128 value)
        internal
        override(ERC721, ERC721Enumerable)
    {
        super._increaseBalance(account, value);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
